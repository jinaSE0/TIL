1. 불린형 반환
  비교연산자는 불린형을 반환하는데
  반환된 불린 값을 변수에 할당할 수 있음

  let result = 5 > 4; // 비교 결과를 변수에 할당
  alert( result ); // true
  
2.문자열 비교
  자바스크립트는 ‘사전’ 순으로 문자열을 비교합니다. 
  '사전편집(lexicographical)'순이라고 불리기도 하는 이 기준을 적용하면 
  사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단됩니다.
  
  alert( 'Z' > 'A' ); // true
  alert( 'Glow' > 'Glee' ); // true
  alert( 'Bee' > 'Be' ); // true
  
  정확히는 사전 순이 아니라 유니코드 순입니다.
  자바스크립트의 문자열 비교 알고리즘은 사전이나 전화번호부에서 사용되는 정렬 알고리즘과 아주 유사하지만, 완전히 같진 않습니다.

  차이점 중 하나는 자바스크립트는 대·소문자를 따진다는 것입니다. 대문자 'A'와 소문자 'a'를 비교했을 때 소문자 'a'가 더 큽니다. 
  자바스크립트 내부에서 사용되는 인코딩 표인 유니코드에선 소문자가 대문자보다 더 큰 인덱스를 갖기 때문이죠. 
  
 
 3. 다른 형을 가진 값 간의 비교
  비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 숫자형으로 바꿉니다.

  예시:

  alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행됩니다.
  alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행됩니다.
  불린값의 경우 true는 1, false는 0으로 변환된 후 비교가 이뤄집니다.

  예시:

  alert( true == 1 ); // true
  alert( false == 0 ); // true
  
  *흥미로운 상황
  동시에 일어나지 않을 법한 두 상황이 동시에 일어나는 경우도 있습니다.

  동등 비교(==) 시 true를 반환함
  논리 평가 시 값 하나는 true, 다른 값 하나는 false를 반환함
  예시:

  let a = 0;
  alert( Boolean(a) ); // false

  let b = "0";
  alert( Boolean(b) ); // true

  alert(a == b); // true!

  동등 비교 연산자 ==는 (예시에서 문자열 "0"을 숫자 0으로 변환시킨 것처럼) 피연산자를 숫자형으로 바꾸지만, 
  'Boolean’을 사용한 명시적 변환에는 다른 규칙이 사용되기 때문입니다. 
  -> 찬찬히 생각하면 알겠는데... 언뜻 생각하면 읭?스럽다.
  
 4. null이나 undefined와 비교하기
 산술 연산자나 기타 비교 연산자 <, >, <=, >=를 사용하여 null과 undefined를 비교
null과 undefined는 숫자형으로 변환됩니다. null은 0, undefined는 NaN으로 변합니다.

5.null vs 0
null과 0을 비교해 봅시다.

alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true

위 비교 결과는 논리에 맞지 않아 보입니다. (3)에서 null은 0보다 크거나 같다고 했기 때문에,
(1)이나 (2) 중 하나는 참이어야 하는데 둘 다 거짓을 반환하고 있네요.

이런 결과가 나타나는 이유는 동등 연산자 ==와 기타 비교 연산자 <, >, <=, >=의 동작 방식이 다르기 때문입니다.
(1)에서 null > 0이 거짓을, (3)에서 null >= 0이 참을 반환하는 이유는 (기타 비교 연산자의 동작 원리에 따라) 
null이 숫자형으로 변환돼 0이 되기 때문입니다.

그런데 동등 연산자 ==는 피연산자가 undefined나 null일 때 형 변환을 하지 않습니다. 
undefined와 null을 비교하는 경우에만 true를 반환하고, 그 이외의 경우(null이나 undefined를 다른 값과 비교할 때)는
무조건 false를 반환합니다. 이런 이유 때문에 (2)는 거짓을 반환합니다.

6. 비교가 불가능한 undefined
undefined를 다른 값과 비교해서는 안 됩니다.

alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
위 예시를 보면 undefined는 0을 매우 싫어하는 것처럼 보입니다. 항상 false를 반환하고 있네요.

이런 결과는 아래와 같은 이유 때문에 발생합니다.

(1)과(2)에선 undefined가 NaN으로 변환되는데(숫자형으로의 변환), 
NaN이 피연산자인 경우 비교 연산자는 항상 false를 반환합니다.
undefined는 null이나 undefined와 같고, 그 이외의 값과는 같지 않기 때문에 (3)은 false를 반환합니다.


주의할 점
일치 연산자 ===를 제외한 비교 연산자의 피연산자에 undefined나 null이 오지 않도록 특별히 주의하시기 바랍니다.
또한, undefined나 null이 될 가능성이 있는 변수가 <, >, <=, >=의 피연산자가 되지 않도록 주의하시기 바랍니다. 
명확한 의도를 갖고 있지 않은 이상 말이죠. 
만약 변수가 undefined나 null이 될 가능성이 있다고 판단되면, 이를 따로 처리하는 코드를 추가하시기 바랍니다.
 
https://ko.javascript.info/comparison
